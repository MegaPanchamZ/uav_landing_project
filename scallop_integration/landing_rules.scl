// 🛩️ UAV Landing Zone Detection - Scallop Rules
// ==============================================
//
// Neuro-symbolic reasoning for safe UAV landing using 24 semantic classes.
// Input: Probabilistic facts from neural network segmentation
// Output: Landing decisions with explanations and confidence scores

// ============================================================================
// INPUT FACTS (from Neural Network)
// ============================================================================

// Pixel-level semantic classification with confidence
type PixelClass(x: i32, y: i32, class: String, prob: f32)

// Example input facts (generated by neural network):
// PixelClass(100, 200, "paved-area", 0.95)
// PixelClass(150, 200, "grass", 0.85) 
// PixelClass(200, 300, "water", 0.92)
// PixelClass(250, 400, "person", 0.78)

// ============================================================================
// LANDING SURFACE CLASSIFICATION
// ============================================================================

// Define landing surface safety levels
rel safe_surface(x, y) :- PixelClass(x, y, "paved-area", p), p > 0.8
rel safe_surface(x, y) :- PixelClass(x, y, "dirt", p), p > 0.7
rel safe_surface(x, y) :- PixelClass(x, y, "grass", p), p > 0.7
rel safe_surface(x, y) :- PixelClass(x, y, "gravel", p), p > 0.6

// Conditional safe surfaces (depends on context)
rel conditional_safe(x, y, reason) :- 
    PixelClass(x, y, "vegetation", p), p > 0.6,
    !nearby_hazard(x, y, 25),
    reason = "low_vegetation_clear_area"

rel conditional_safe(x, y, reason) :-
    PixelClass(x, y, "roof", p), p > 0.7,
    flat_roof(x, y),
    !nearby_hazard(x, y, 30),
    reason = "flat_roof_emergency_landing"

// ============================================================================
// HAZARD DETECTION
// ============================================================================

// Critical hazards - must avoid
rel critical_hazard(x, y, hazard_type) :- 
    PixelClass(x, y, "water", p), p > 0.5,
    hazard_type = "water_body"

rel critical_hazard(x, y, hazard_type) :- 
    PixelClass(x, y, "pool", p), p > 0.5,
    hazard_type = "water_pool"

rel critical_hazard(x, y, hazard_type) :- 
    PixelClass(x, y, "person", p), p > 0.4,
    hazard_type = "human_presence"

rel critical_hazard(x, y, hazard_type) :- 
    PixelClass(x, y, "dog", p), p > 0.4,
    hazard_type = "animal_presence"

// Dynamic hazards - moving objects
rel dynamic_hazard(x, y, hazard_type) :- 
    PixelClass(x, y, "car", p), p > 0.5,
    hazard_type = "vehicle"

rel dynamic_hazard(x, y, hazard_type) :- 
    PixelClass(x, y, "bicycle", p), p > 0.5,
    hazard_type = "bicycle"

// Physical obstacles
rel physical_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "tree", p), p > 0.6,
    obstacle_type = "tree"

rel physical_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "wall", p), p > 0.7,
    obstacle_type = "wall"

rel physical_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "fence", p), p > 0.7,
    obstacle_type = "fence"

rel physical_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "fence-pole", p), p > 0.7,
    obstacle_type = "fence_pole"

rel physical_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "obstacle", p), p > 0.6,
    obstacle_type = "general_obstacle"

// Potential obstacles (assessment needed)
rel potential_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "rocks", p), p > 0.6,
    obstacle_type = "rocks"

rel potential_obstacle(x, y, obstacle_type) :- 
    PixelClass(x, y, "bald-tree", p), p > 0.6,
    obstacle_type = "dead_tree"

// ============================================================================
// SPATIAL REASONING
// ============================================================================

// Check if there are hazards nearby (within radius)
rel nearby_hazard(x, y, radius) :-
    critical_hazard(hx, hy, _),
    distance_within(x, y, hx, hy, radius)

rel nearby_hazard(x, y, radius) :-
    dynamic_hazard(hx, hy, _),
    distance_within(x, y, hx, hy, radius)

rel nearby_hazard(x, y, radius) :-
    physical_obstacle(hx, hy, _),
    distance_within(x, y, hx, hy, radius)

// Simple distance check (Euclidean distance approximation)
rel distance_within(x1, y1, x2, y2, radius) :-
    dx = x2 - x1,
    dy = y2 - y1,
    dist_sq = dx * dx + dy * dy,
    radius_sq = radius * radius,
    dist_sq <= radius_sq

// Check if roof is flat (simplified - would need more sophisticated analysis)
rel flat_roof(x, y) :-
    PixelClass(x, y, "roof", p), p > 0.7,
    // Assume flat if surrounded by similar roof pixels
    consistent_roof_area(x, y, 10)

rel consistent_roof_area(x, y, radius) :-
    roof_pixels = count((rx, ry): PixelClass(rx, ry, "roof", rp), rp > 0.5, distance_within(x, y, rx, ry, radius)),
    total_pixels = radius * radius * 3, // Approximate area
    roof_ratio = roof_pixels / total_pixels,
    roof_ratio > 0.8

// ============================================================================
// LANDING ZONE ASSESSMENT
// ============================================================================

// Primary landing zones (safe surfaces with no nearby hazards)
rel primary_landing_zone(zone_id, x, y, confidence) :-
    safe_surface(x, y),
    !nearby_hazard(x, y, 20),
    zone_id = compute_zone_id(x, y),
    confidence = 0.9

// Secondary landing zones (conditional safe with assessment)
rel secondary_landing_zone(zone_id, x, y, confidence, reason) :-
    conditional_safe(x, y, reason),
    !nearby_hazard(x, y, 15),
    zone_id = compute_zone_id(x, y),
    confidence = 0.7

// Emergency landing zones (minimal criteria, higher risk)
rel emergency_landing_zone(zone_id, x, y, confidence, reason) :-
    PixelClass(x, y, class, p), p > 0.5,
    class = "roof",
    !critical_hazard_nearby(x, y, 10),
    zone_id = compute_zone_id(x, y),
    confidence = 0.4,
    reason = "emergency_roof_landing"

// Check for critical hazards only (less restrictive)
rel critical_hazard_nearby(x, y, radius) :-
    critical_hazard(hx, hy, _),
    distance_within(x, y, hx, hy, radius)

// ============================================================================
// ZONE ANALYSIS AND SCORING
// ============================================================================

// Calculate landing zone area and quality
rel landing_zone_analysis(zone_id, area_pixels, safety_score, hazard_count, zone_type) :-
    primary_landing_zone(zone_id, _, _, _),
    area_pixels = count((x, y): primary_landing_zone(zone_id, x, y, _)),
    hazard_count = count((hx, hy): nearby_hazard_in_zone(zone_id, hx, hy)),
    safety_score = compute_primary_safety_score(area_pixels, hazard_count),
    zone_type = "primary"

rel landing_zone_analysis(zone_id, area_pixels, safety_score, hazard_count, zone_type) :-
    secondary_landing_zone(zone_id, _, _, _, _),
    area_pixels = count((x, y): secondary_landing_zone(zone_id, x, y, _, _)),
    hazard_count = count((hx, hy): nearby_hazard_in_zone(zone_id, hx, hy)),
    safety_score = compute_secondary_safety_score(area_pixels, hazard_count),
    zone_type = "secondary"

rel landing_zone_analysis(zone_id, area_pixels, safety_score, hazard_count, zone_type) :-
    emergency_landing_zone(zone_id, _, _, _, _),
    area_pixels = count((x, y): emergency_landing_zone(zone_id, x, y, _, _)),
    hazard_count = count((hx, hy): critical_hazard_nearby_zone(zone_id, hx, hy)),
    safety_score = compute_emergency_safety_score(area_pixels, hazard_count),
    zone_type = "emergency"

// Helper relations for zone-based hazard counting
rel nearby_hazard_in_zone(zone_id, hx, hy) :-
    primary_landing_zone(zone_id, zx, zy, _),
    nearby_hazard(zx, zy, 30),
    distance_within(zx, zy, hx, hy, 30)

rel nearby_hazard_in_zone(zone_id, hx, hy) :-
    secondary_landing_zone(zone_id, zx, zy, _, _),
    nearby_hazard(zx, zy, 25),
    distance_within(zx, zy, hx, hy, 25)

rel critical_hazard_nearby_zone(zone_id, hx, hy) :-
    emergency_landing_zone(zone_id, zx, zy, _, _),
    critical_hazard_nearby(zx, zy, 15),
    distance_within(zx, zy, hx, hy, 15)

// ============================================================================
// FINAL LANDING RECOMMENDATIONS
// ============================================================================

// Recommend landing zones based on criteria
rel recommend_landing(zone_id, zone_type, final_confidence, explanation) :-
    landing_zone_analysis(zone_id, area_pixels, safety_score, hazard_count, zone_type),
    zone_type = "primary",
    area_pixels > 1000,  // Minimum area requirement
    safety_score > 0.8,
    final_confidence = safety_score * area_confidence_factor(area_pixels),
    explanation = generate_primary_explanation(area_pixels, safety_score, hazard_count)

rel recommend_landing(zone_id, zone_type, final_confidence, explanation) :-
    landing_zone_analysis(zone_id, area_pixels, safety_score, hazard_count, zone_type),
    zone_type = "secondary", 
    area_pixels > 800,   // Slightly smaller area acceptable
    safety_score > 0.6,
    !better_primary_available(),
    final_confidence = safety_score * area_confidence_factor(area_pixels) * 0.8,
    explanation = generate_secondary_explanation(area_pixels, safety_score, hazard_count)

rel recommend_landing(zone_id, zone_type, final_confidence, explanation) :-
    landing_zone_analysis(zone_id, area_pixels, safety_score, hazard_count, zone_type),
    zone_type = "emergency",
    area_pixels > 400,   // Much smaller area acceptable in emergency
    safety_score > 0.3,
    !better_zone_available(),
    emergency_situation(),
    final_confidence = safety_score * area_confidence_factor(area_pixels) * 0.5,
    explanation = generate_emergency_explanation(area_pixels, safety_score, hazard_count)

// ============================================================================
// HELPER FUNCTIONS AND CONDITIONS
// ============================================================================

// Check if better alternatives exist
rel better_primary_available() :-
    recommend_landing(_, "primary", conf, _),
    conf > 0.7

rel better_zone_available() :-
    recommend_landing(_, zone_type, conf, _),
    zone_type != "emergency",
    conf > 0.5

// Emergency situation detection (would be input from flight controller)
rel emergency_situation() :-
    // This would be provided as external fact in emergency scenarios
    false  // Default: no emergency

// Confidence factors based on area size
rel area_confidence_factor(area_pixels) = factor :-
    area_pixels > 2000,
    factor = 1.0

rel area_confidence_factor(area_pixels) = factor :-
    area_pixels <= 2000, area_pixels > 1000,
    factor = 0.9

rel area_confidence_factor(area_pixels) = factor :-
    area_pixels <= 1000, area_pixels > 500,
    factor = 0.7

rel area_confidence_factor(area_pixels) = factor :-
    area_pixels <= 500,
    factor = 0.5

// Safety score computation functions
rel compute_primary_safety_score(area_pixels, hazard_count) = score :-
    base_score = 0.9,
    area_bonus = min(area_pixels / 2000.0, 0.1),
    hazard_penalty = hazard_count * 0.05,
    score = max(base_score + area_bonus - hazard_penalty, 0.0)

rel compute_secondary_safety_score(area_pixels, hazard_count) = score :-
    base_score = 0.7,
    area_bonus = min(area_pixels / 1500.0, 0.1),
    hazard_penalty = hazard_count * 0.07,
    score = max(base_score + area_bonus - hazard_penalty, 0.0)

rel compute_emergency_safety_score(area_pixels, hazard_count) = score :-
    base_score = 0.4,
    area_bonus = min(area_pixels / 800.0, 0.1),
    hazard_penalty = hazard_count * 0.1,
    score = max(base_score + area_bonus - hazard_penalty, 0.0)

// Zone ID computation (simple grid-based)
rel compute_zone_id(x, y) = zone_id :-
    grid_x = x / 50,
    grid_y = y / 50,
    zone_id = grid_x * 1000 + grid_y

// Explanation generation
rel generate_primary_explanation(area_pixels, safety_score, hazard_count) = explanation :-
    explanation = $format("Primary landing zone: {} pixels, safety score {:.2f}, {} nearby hazards", area_pixels, safety_score, hazard_count)

rel generate_secondary_explanation(area_pixels, safety_score, hazard_count) = explanation :-
    explanation = $format("Secondary landing zone: {} pixels, safety score {:.2f}, {} nearby hazards - requires assessment", area_pixels, safety_score, hazard_count)

rel generate_emergency_explanation(area_pixels, safety_score, hazard_count) = explanation :-
    explanation = $format("Emergency landing zone: {} pixels, safety score {:.2f}, {} critical hazards - use only in emergency", area_pixels, safety_score, hazard_count)

// ============================================================================
// QUERY RELATIONS (External Interface)
// ============================================================================

// Main query for landing recommendations
rel query_landing_recommendations(zone_id, zone_type, confidence, explanation) :-
    recommend_landing(zone_id, zone_type, confidence, explanation)

// Query for hazard analysis
rel query_hazards(x, y, hazard_type, severity) :-
    critical_hazard(x, y, hazard_type),
    severity = "critical"

rel query_hazards(x, y, hazard_type, severity) :-
    dynamic_hazard(x, y, hazard_type),
    severity = "dynamic"

rel query_hazards(x, y, hazard_type, severity) :-
    physical_obstacle(x, y, hazard_type),
    severity = "obstacle"

// Query for zone analysis
rel query_zone_analysis(zone_id, area_pixels, safety_score, zone_type) :-
    landing_zone_analysis(zone_id, area_pixels, safety_score, _, zone_type)

// Query for safe surfaces
rel query_safe_surfaces(x, y, surface_type) :-
    safe_surface(x, y),
    PixelClass(x, y, surface_type, _)

rel query_safe_surfaces(x, y, surface_type) :-
    conditional_safe(x, y, surface_type) 